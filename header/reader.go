// Package header
package header

// SourcePort Source TCP port number (2 bytes or 16 bits):
// The source TCP port number represents the sending device.
func (p Packet) SourcePort() uint16 {
	return uint16(p[1]) | (uint16(p[0]) << 8)
}

// DestinationPort Destination TCP port number (2 bytes or 16 bits):
// The destination TCP port number is the communication endpoint for the receiving device.
func (p Packet) DestinationPort() uint16 {
	return uint16(p[3]) | uint16(p[2])<<8

}

// SequenceNumber Sequence number (4 bytes or 32 bits):
// Message senders use sequence numbers to mark the ordering of a group of messages.
func (p Packet) SequenceNumber() uint32 {
	return uint32(p[7]) | uint32(p[6])<<8 | uint32(p[5])<<16 | uint32(p[4])<<24
}

// AckNumber Acknowledgment number (4 bytes or 32 bits): Both senders and receivers
// use the acknowledgment numbers field to communicate the sequence numbers of
// messages that are either recently received or expected to be sent.
func (p Packet) AckNumber() uint32 {
	return uint32(p[11]) | uint32(p[10])<<8 | uint32(p[9])<<16 | uint32(p[8])<<24
}

// DO TCP data offset (4 bits): The data offset field stores the total size of
// a TCP header in multiples of four bytes. A header not using the optional
// TCP field has a data offset of 5 (representing 20 bytes), while a header
// using the maximum-sized optional field has a data offset of 15 (representing 60 bytes).
func (p Packet) DO() uint8 {
	return uint8(uint16(uint16(p[13])|uint16(p[12])<<8) >> 12)
}

// RSV Reserved data (3 bits): Reserved data in TCP headers always has a value of zero.
// This field aligns the total header size as a multiple of four bytes,
// which is important for the efficiency of computer data processing.
func (p Packet) RSV() uint8 {
	return uint8(uint16(uint16(uint16(p[13])|uint16(p[12])<<8)<<4) >> 13)
}

// Flags Control flags (up to 9 bits): TCP uses a set of six standard and
// three extended control flags—each an individual bit representing On or Off—to manage
// data flow in specific situations.
func (p Packet) Flags() (flags struct {
	NS  bool
	CWR bool
	ECE bool
	URG bool
	ACK bool
	PSH bool
	RST bool
	SYN bool
	FIN bool
}) {

	if uint16(uint16(uint16(p[13])|uint16(p[12])<<8)<<7)>>15 == 1 {
		flags.NS = true
	}

	if uint16(uint16(uint16(p[13])|uint16(p[12])<<8)<<8)>>15 == 1 {
		flags.CWR = true
	}

	if uint16(uint16(uint16(p[13])|uint16(p[12])<<8)<<9)>>15 == 1 {
		flags.ECE = true
	}

	if uint16(uint16(uint16(p[13])|uint16(p[12])<<8)<<10)>>15 == 1 {
		flags.URG = true
	}

	if uint16(uint16(uint16(p[13])|uint16(p[12])<<8)<<11)>>15 == 1 {
		flags.ACK = true
	}

	if uint16(uint16(uint16(p[13])|uint16(p[12])<<8)<<12)>>15 == 1 {
		flags.PSH = true
	}

	if uint16(uint16(uint16(p[13])|uint16(p[12])<<8)<<13)>>15 == 1 {
		flags.RST = true
	}

	if uint16(uint16(uint16(p[13])|uint16(p[12])<<8)<<14)>>15 == 1 {
		flags.SYN = true
	}

	if uint16(uint16(uint16(p[13])|uint16(p[12])<<8)<<15)>>15 == 1 {
		flags.FIN = true
	}

	return flags
}

// Window Window size (2 bytes or 16 bits): TCP senders use a number,
// called window size, to regulate how much data they send to a receiver before
// requiring an acknowledgment in return. If the window size is too small,
// network data transfer is unnecessarily slow. If the window size is too large,
// the network link may become saturated,
// or the receiver may not be able to process incoming data quickly enough,
// resulting in slow performance. Windowing algorithms built into the protocol
// dynamically calculate size values and use this field of TCP headers to
// coordinate changes between senders and receivers.
func (p Packet) Window() uint16 {
	return uint16(uint16(p[15]) | uint16(p[14])<<8)
}

// Checksum TCP checksum (2 bytes or 16 bits): The checksum value inside
// a TCP header is generated by the protocol sender as a mathematical technique
// to help the receiver detect messages that are corrupted or tampered with.
func (p Packet) Checksum() uint16 {
	return uint16(uint16(p[17]) | uint16(p[16])<<8)
}

// UrgentPointer Urgent pointer (2 bytes or 16 bits): The urgent pointer field
// is often set to zero and ignored, but in conjunction with one of the control
// flags, it can be used as a data offset to mark a subset of a message as
// requiring priority processing.
func (p Packet) UrgentPointer() uint16 {
	return uint16(uint16(p[19]) | uint16(p[18])<<8)
}

// Options TCP optional data (0 to 40 bytes): Usages of optional TCP data
// include support for special acknowledgment and window scaling algorithms.
// func (p *Packet) Options() {
// 	fmt.Println("Options")
// }
